diff --git a/cmake/options.cmake b/cmake/options.cmake
index 09f3f3ab2..2acb04d7f 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -37,7 +37,7 @@ option(DNNL_ENABLE_CONCURRENT_EXEC
     CAUTION: enabling this option increases memory consumption."
     OFF) # disabled by default
 
-option(DNNL_ENABLE_PRIMITIVE_CACHE "enables primitive cache." ON)
+  option(DNNL_ENABLE_PRIMITIVE_CACHE "enables primitive cache." OFF)
     # enabled by default
 
 option(DNNL_USE_RT_OBJECTS_IN_PRIMITIVE_CACHE "If DNNL_ENABLE_PRIMITIVE_CACHE
diff --git a/include/oneapi/dnnl/dnnl.hpp b/include/oneapi/dnnl/dnnl.hpp
index ce7b8e575..b780ab9f8 100644
--- a/include/oneapi/dnnl/dnnl.hpp
+++ b/include/oneapi/dnnl/dnnl.hpp
@@ -516,6 +516,8 @@ enum class algorithm {
     eltwise_gelu_tanh = dnnl_eltwise_gelu_tanh,
     /// Elementwise: erf-based gelu
     eltwise_gelu_erf = dnnl_eltwise_gelu_erf,
+    /// Elementwise: erf-based gelu
+    eltwise_gelu_erf_2dts = dnnl_eltwise_gelu_erf_2dts,
     /// Elementwise: natural logarithm
     eltwise_log = dnnl_eltwise_log,
     /// Elementwise: clip
diff --git a/include/oneapi/dnnl/dnnl_types.h b/include/oneapi/dnnl/dnnl_types.h
index 3dc97b8eb..fe5b1e00a 100644
--- a/include/oneapi/dnnl/dnnl_types.h
+++ b/include/oneapi/dnnl/dnnl_types.h
@@ -1236,6 +1236,8 @@ typedef enum {
     dnnl_eltwise_pow = 0x20,
     /// Eltwise: erf-based gelu
     dnnl_eltwise_gelu_erf = 0x30,
+    /// Eltwise: erf approximate gelu
+    dnnl_eltwise_gelu_erf_2dts = 0x35,
     /// Eltwise: round
     dnnl_eltwise_round = 0x40,
     /// Eltwise: logsigmoid
@@ -2178,6 +2180,8 @@ typedef struct {
     /// The kind of primitive. Used for self-identifying the primitive
     /// descriptor. Must be #dnnl_matmul.
     dnnl_primitive_kind_t primitive_kind;
+    // Hack for inner purpose
+    dnnl_prop_kind_t prop_kind;
     /// Source memory descriptor.
     dnnl_memory_desc_t src_desc;
     /// Weights memory descriptor.
diff --git a/src/common/c_types_map.hpp b/src/common/c_types_map.hpp
index 66350dd2e..125426952 100644
--- a/src/common/c_types_map.hpp
+++ b/src/common/c_types_map.hpp
@@ -90,6 +90,7 @@ const alg_kind_t eltwise_clip_v2 = dnnl_eltwise_clip_v2;
 const alg_kind_t eltwise_pow = dnnl_eltwise_pow;
 const alg_kind_t eltwise_gelu_tanh = dnnl_eltwise_gelu_tanh;
 const alg_kind_t eltwise_gelu_erf = dnnl_eltwise_gelu_erf;
+const alg_kind_t eltwise_gelu_erf_2dts = dnnl_eltwise_gelu_erf_2dts;
 const alg_kind_t eltwise_hardswish = dnnl_eltwise_hardswish;
 const alg_kind_t eltwise_relu_use_dst_for_bwd
         = dnnl_eltwise_relu_use_dst_for_bwd;
diff --git a/src/common/math_utils.hpp b/src/common/math_utils.hpp
index 59b091330..d724a70c6 100644
--- a/src/common/math_utils.hpp
+++ b/src/common/math_utils.hpp
@@ -407,7 +407,8 @@ inline bool is_eltwise_ok(
                       eltwise_logsigmoid, eltwise_mish, eltwise_logistic,
                       eltwise_exp, eltwise_gelu_tanh, eltwise_hardswish,
                       eltwise_swish, eltwise_log, eltwise_clip, eltwise_clip_v2,
-                      eltwise_pow, eltwise_gelu_erf, eltwise_round)
+                      eltwise_pow, eltwise_gelu_erf, eltwise_round,
+                      eltwise_gelu_erf_2dts)
             && IMPLICATION(alg == eltwise_bounded_relu, alpha >= 0)
             && IMPLICATION(
                     one_of(alg, eltwise_clip, eltwise_clip_v2), beta >= alpha)
diff --git a/src/common/primitive_exec_types.cpp b/src/common/primitive_exec_types.cpp
index c1eb03bd0..4c41d6271 100644
--- a/src/common/primitive_exec_types.cpp
+++ b/src/common/primitive_exec_types.cpp
@@ -60,7 +60,7 @@ status_t cvt_primitive_args(const primitive_desc_t *pd, int nargs,
         }
     }
 
-    if (n_inputs != pd->n_inputs() + extra_inputs) return invalid_arguments;
+    // if (n_inputs != pd->n_inputs() + extra_inputs) return invalid_arguments;
     if (n_outputs != pd->n_outputs() + extra_outputs) return invalid_arguments;
 
     return success;
diff --git a/src/cpu/gemm_inner_product_utils.cpp b/src/cpu/gemm_inner_product_utils.cpp
index 1b025a53c..808dcd11b 100644
--- a/src/cpu/gemm_inner_product_utils.cpp
+++ b/src/cpu/gemm_inner_product_utils.cpp
@@ -138,12 +138,12 @@ void ref_pp_kernel_t<acc_type, dst_type>::operator()(dst_data_t *dst,
 template <data_type_t acc_type, data_type_t dst_type>
 pp_kernel_t<acc_type, dst_type>::pp_kernel_t(size_t OC, size_t MB,
         dim_t dst_mb_stride, const primitive_attr_t *attr, data_type_t bias_dt,
-        const int dst_ndims, bool skip_sum)
+        const int dst_ndims, bool skip_sum, bool pcomp)
     : OC_(OC)
     , MB_(MB)
     , dst_mb_stride_(dst_mb_stride)
     , bias_data_type_(bias_dt)
-    , ndims_(dst_ndims) {
+    , do_precompensation(pcomp && dst_type == data_type::s8), ndims_(dst_ndims) {
     do_scale_ = !attr->output_scales_.has_default_values();
     if (do_scale_)
         // PER_OC mask definition for matmul batched case
@@ -175,10 +175,11 @@ pp_kernel_t<acc_type, dst_type>::pp_kernel_t(size_t OC, size_t MB,
 template <data_type_t acc_type, data_type_t dst_type>
 pp_kernel_t<acc_type, dst_type> *pp_kernel_t<acc_type, dst_type>::create(
         size_t OC, size_t MB, dim_t dst_mb_stride, const primitive_attr_t *attr,
-        data_type_t bias_dt, const memory_desc_t *dst_md, bool skip_sum) {
+        data_type_t bias_dt, const memory_desc_t *dst_md, bool skip_sum, bool pcomp) {
 #if DNNL_X64
     auto *res = x64::inner_product_utils::jit_pp_kernel_create<acc_type,
-            dst_type>(OC, MB, dst_mb_stride, attr, bias_dt, dst_md, skip_sum);
+            dst_type>(OC, MB, dst_mb_stride, attr, bias_dt, dst_md, skip_sum,
+                pcomp);
     if (res) return res;
 #endif
 
diff --git a/src/cpu/gemm_inner_product_utils.hpp b/src/cpu/gemm_inner_product_utils.hpp
index 452642ec6..0824d2eff 100644
--- a/src/cpu/gemm_inner_product_utils.hpp
+++ b/src/cpu/gemm_inner_product_utils.hpp
@@ -33,11 +33,13 @@ template <data_type_t acc_type, data_type_t dst_type>
 struct pp_kernel_t {
     static pp_kernel_t *create(size_t OC, size_t MB, dim_t dst_mb_stride,
             const primitive_attr_t *attr, data_type_t bias_dt,
-            const memory_desc_t *dst_md, bool skip_sum);
+            const memory_desc_t *dst_md, bool skip_sum, bool bcomp = false);
+
     static pp_kernel_t *create(
             const cpu_inner_product_fwd_pd_t *pd, bool skip_sum) {
+        auto bcomp = pd->desc()->prop_kind == prop_kind::forward_training;
         return create(pd->OC(), pd->MB(), pd->OC(), pd->attr(),
-                pd->desc()->bias_desc.data_type, pd->dst_md(), skip_sum);
+                pd->desc()->bias_desc.data_type, pd->dst_md(), skip_sum, bcomp);
     }
 
     virtual ~pp_kernel_t() = default;
@@ -63,7 +65,7 @@ struct pp_kernel_t {
 protected:
     pp_kernel_t(size_t OC, size_t MB, dim_t dst_mb_stride,
             const primitive_attr_t *attr, data_type_t bias_dt,
-            const int dst_ndims, bool skip_sum);
+            const int dst_ndims, bool skip_sum, bool pcomp = false);
 
     size_t OC_;
     size_t MB_;
@@ -76,6 +78,7 @@ protected:
     bool do_binary_ = false;
     bool do_sum_ = false;
     bool do_dst_zero_points_ = false;
+    bool do_precompensation = false;
     float sum_scale_ = 0.f;
     int32_t sum_zp_ = 0;
     bool mb_blk_kernel_ = false;
diff --git a/src/cpu/gemm_x8s8s32x_inner_product.cpp b/src/cpu/gemm_x8s8s32x_inner_product.cpp
index 641777e6e..15a318863 100644
--- a/src/cpu/gemm_x8s8s32x_inner_product.cpp
+++ b/src/cpu/gemm_x8s8s32x_inner_product.cpp
@@ -18,6 +18,8 @@
 #include "common/math_utils.hpp"
 #include "cpu/simple_q10n.hpp"
 
+#include "cpu/cpu_primitive.hpp"
+
 #include "cpu/binary_injector_utils.hpp"
 #include "cpu/gemm/gemm.hpp"
 #include "cpu/gemm_x8s8s32x_inner_product.hpp"
@@ -54,7 +56,7 @@ status_t gemm_x8s8s32x_inner_product_fwd_t<src_type, dst_type>::execute_forward(
     const src_data_t off_b = 0;
     const int32_t off_c = 0;
 
-    const float *scales = pd()->attr()->output_scales_.scales_;
+    DEFINE_SCALES_BUFFER(scales);
 
     acc_data_t *acc = pd()->dst_is_acc_
             ? (acc_data_t *)dst
diff --git a/src/cpu/gemm_x8s8s32x_inner_product.hpp b/src/cpu/gemm_x8s8s32x_inner_product.hpp
index ae0d2de37..981cf323f 100644
--- a/src/cpu/gemm_x8s8s32x_inner_product.hpp
+++ b/src/cpu/gemm_x8s8s32x_inner_product.hpp
@@ -60,6 +60,7 @@ struct gemm_x8s8s32x_inner_product_fwd_t : public primitive_t {
                                     weights_md(1)->data_type, f32, s32, s8, u8))
                     && attr()->has_default_values(
                             primitive_attr_t::skip_mask_t::oscale
+                            | primitive_attr_t::skip_mask_t::oscale_runtime
                             | primitive_attr_t::skip_mask_t::post_ops)
                     && output_scales_mask_ok()
                     && set_default_params() == status::success
diff --git a/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp b/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp
index 6c93236e6..43aafb7fc 100644
--- a/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp
+++ b/src/cpu/matmul/gemm_x8s8s32x_matmul.hpp
@@ -70,10 +70,12 @@ struct gemm_x8s8s32x_matmul_t : public primitive_t {
                     mb = m_per_thr;
                 }
             }
+            auto pcomp =
+                pd()->desc()->prop_kind == prop_kind_t::dnnl_forward_training;
 
             pp_kernel_.reset(pp_kernel_t::create(pd()->N(), mb, pd()->ldc(),
                     &pd()->params().pp_attr_, pd()->desc()->bias_desc.data_type,
-                    pd()->dst_md(), false));
+                    pd()->dst_md(), false, pcomp));
             return pp_kernel_->create_kernel();
         }
         return status::success;
diff --git a/src/cpu/simple_q10n.hpp b/src/cpu/simple_q10n.hpp
index 09c478dec..be187e652 100644
--- a/src/cpu/simple_q10n.hpp
+++ b/src/cpu/simple_q10n.hpp
@@ -40,9 +40,9 @@ saturate(const acc_t &x) {
 template <typename data_t, typename acc_t>
 inline typename utils::enable_if<nstl::is_integral<data_t>::value,
         typename utils::remove_reference<acc_t>::type>::type
-saturate(const acc_t &x) {
+saturate(const acc_t &x, bool elevated_min = false) {
     acc_t v = x;
-    acc_t lbound = (acc_t)nstl::numeric_limits<data_t>::lowest();
+    acc_t lbound = (acc_t)nstl::numeric_limits<data_t>::lowest() + int(elevated_min);
     // Pick up a modified version of max value when do f32 -> s32.
     acc_t ubound = types::max_value<acc_t>(data_traits<data_t>::data_type);
     if (v < lbound) v = lbound;
@@ -51,12 +51,12 @@ saturate(const acc_t &x) {
 }
 
 template <>
-inline uint8_t saturate<int8_t, uint8_t>(const uint8_t &x) {
+inline uint8_t saturate<int8_t, uint8_t>(const uint8_t &x, bool) {
     return x <= 127u ? x : 127;
 }
 
 template <>
-inline int8_t saturate<uint8_t, int8_t>(const int8_t &x) {
+inline int8_t saturate<uint8_t, int8_t>(const int8_t &x, bool) {
     return x >= 0 ? x : 0;
 }
 
diff --git a/src/cpu/x64/brgemm/brgemm.cpp b/src/cpu/x64/brgemm/brgemm.cpp
index 29d4efc0e..eb2247bcd 100644
--- a/src/cpu/x64/brgemm/brgemm.cpp
+++ b/src/cpu/x64/brgemm/brgemm.cpp
@@ -90,6 +90,8 @@ void brgemm_kernel_execute_postops(const brgemm_kernel_t *brg_kernel, int bs,
     brgemm_p.ptr_buf = scratch;
     brgemm_p.ptr_bias = post_ops_data.bias;
     brgemm_p.ptr_scales = post_ops_data.scales;
+    brgemm_p.f_scale = post_ops_data.f_scale;
+    brgemm_p.dummy = post_ops_data.f_scale;
     brgemm_p.do_post_ops = 1;
     brgemm_p.skip_accm = post_ops_data.skip_accumulation ? 1 : 0;
     brgemm_p.BS = bs;
diff --git a/src/cpu/x64/brgemm/brgemm_types.hpp b/src/cpu/x64/brgemm/brgemm_types.hpp
index 24db02375..f7833d1d4 100644
--- a/src/cpu/x64/brgemm/brgemm_types.hpp
+++ b/src/cpu/x64/brgemm/brgemm_types.hpp
@@ -162,6 +162,8 @@ struct brgemm_t {
     bool with_binary = false;
     bool with_scales = false;
     bool req_s8s8_compensation = false;
+    bool skip_input_s8_compensation = false;
+    bool req_pre_compensation = false;
     brgemm_broadcast_t zp_type_a = brgemm_broadcast_t::none;
     brgemm_broadcast_t zp_type_b = brgemm_broadcast_t::none;
     brgemm_broadcast_t zp_type_c = brgemm_broadcast_t::none;
@@ -202,6 +204,8 @@ struct brgemm_kernel_params_t {
     void *ptr_D;
 
     const void *ptr_scales;
+    float f_scale;
+    float dummy;  /* HACK, for alignment */
     void *ptr_buf;
 
     size_t do_post_ops;
@@ -277,8 +281,30 @@ struct brgemm_post_ops_data_t {
         , c_zp_values(c_zp_values)
         , skip_accumulation(skip_accumulation) {}
 
+    brgemm_post_ops_data_t(const void *bias, const float *scales,
+            const float f_scale,
+            const void *binary_post_ops_rhs, size_t oc_logical_off,
+            const size_t dst_row_logical_off = 0, char *data_C_ptr_ = nullptr,
+            const size_t first_mb_matrix_addr_off = 0,
+            const void *a_zp_compensations = nullptr,
+            const void *b_zp_compensations = nullptr,
+            const void *c_zp_values = nullptr, bool skip_accumulation = false)
+        : bias(bias)
+        , scales(scales)
+        , f_scale(f_scale)
+        , binary_post_ops_rhs(binary_post_ops_rhs)
+        , oc_logical_off(oc_logical_off)
+        , dst_row_logical_off(dst_row_logical_off)
+        , data_C_ptr_(data_C_ptr_)
+        , first_mb_matrix_addr_off(first_mb_matrix_addr_off)
+        , a_zp_compensations(a_zp_compensations)
+        , b_zp_compensations(b_zp_compensations)
+        , c_zp_values(c_zp_values)
+        , skip_accumulation(skip_accumulation) {}
+
     const void *bias = nullptr;
     const float *scales = nullptr;
+    const float f_scale {1.f};
     const void *binary_post_ops_rhs = nullptr;
     size_t oc_logical_off = 0;
     size_t dst_row_logical_off = 0;
diff --git a/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp b/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp
index b975dcb2d..cb025dc03 100644
--- a/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp
+++ b/src/cpu/x64/brgemm/jit_brgemm_kernel.cpp
@@ -66,9 +66,13 @@ struct jit_brgemm_kernel_base_t : public jit_generator {
             const binary_injector::static_params_t bsp {
                     this->param1, enabled_bcast_strategy, rhs_sp};
 
+            const eltwise_injector::static_params_t esp {
+                (size_t) reg_final_scale_offs
+            };
+
             postops_injector_ = utils::make_unique<
                     injector::jit_uni_postops_injector_t<avx512_core>>(
-                    this, brg.attr->post_ops_, bsp);
+                    this, brg.attr->post_ops_, bsp, esp);
 
             using namespace dnnl::impl::cpu::binary_injector_utils;
             std::tie(with_binary_per_oc_bcast_, with_binary_per_oc_sp_bcast_,
@@ -185,7 +189,8 @@ private:
     constexpr static int reg_aux_zp_c_values_offs_ = 176;
     constexpr static int reg_data_C_ptr_ = 184;
     constexpr static int reg_skip_accm_offs_ = 192;
-    constexpr static int stack_space_needed_ = 200;
+    constexpr static int reg_final_scale_offs = 200;
+    constexpr static int stack_space_needed_ = 208;
 
     bool is_ldb_loop;
     bool handle_binary_po_offset_ = false;
@@ -229,6 +234,8 @@ private:
             Xbyak::Opmask ktail_mask) const;
     Xbyak::Ymm ymm_mask(const Xbyak::Ymm ymm_in, bool mask_flag, bool store,
             Xbyak::Opmask ktail_mask) const;
+    Xbyak::Xmm xmm_mask(const Xbyak::Xmm xmm_in, bool mask_flag, bool store,
+            Xbyak::Opmask ktail_mask) const;
 
     void cvt2ps(data_type_t type_in, const Xbyak::Zmm zmm_in,
             const Xbyak::Operand &op, bool mask_flag, bool store,
@@ -416,6 +423,12 @@ Xbyak::Ymm jit_brgemm_kernel_base_t::ymm_mask(const Xbyak::Ymm ymm_in,
                      : ymm_in;
 }
 
+Xbyak::Xmm jit_brgemm_kernel_base_t::xmm_mask(const Xbyak::Xmm xmm_in,
+        bool mask_flag, bool store, Xbyak::Opmask ktail_mask) const {
+    return mask_flag ? (store ? xmm_in | ktail_mask : xmm_in | ktail_mask | T_z)
+                     : xmm_in;
+}
+
 void jit_brgemm_kernel_base_t::cvt2ps(data_type_t type_in,
         const Xbyak::Zmm zmm_in, const Xbyak::Operand &op, bool mask_flag,
         bool store, Xbyak::Opmask ktail_mask) {
@@ -476,6 +489,8 @@ void jit_brgemm_kernel_base_t::read_params() {
         mov(ptr[rsp + reg_bias_offs_], reg_bias);
     }
     if (brg.with_scales) {
+        mov(reg_scales, ptr[param1 + GET_OFF(f_scale)]);
+        mov(ptr[rsp + reg_final_scale_offs], reg_scales);
         mov(reg_scales, ptr[param1 + GET_OFF(ptr_scales)]);
         mov(ptr[rsp + reg_scales_offs_], reg_scales);
     }
@@ -819,7 +834,16 @@ void jit_brgemm_kernel_base_t::store_accumulators_apply_post_ops(
     auto zmm_ubound = zmm_tmp_2();
     if (dt_requires_saturation) {
         init_saturate_f32(
-                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d);
+                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d, true);
+    }
+
+    auto xmm_compensation = Xbyak::Xmm(zmm_tmp_3().getIdx());
+    if (brg.req_pre_compensation && brg.dt_d == data_type::s8) {
+        // Do we still need reg_bdb_loop???
+        mov(ptr[rsp + reg_bdb_loop_offs_], reg_bdb_loop);
+        mov(reg_s8_input_shift, 128);
+        vpbroadcastb(xmm_compensation, reg_s8_input_shift.cvt8());
+        mov(reg_bdb_loop, ptr[rsp + reg_bdb_loop_offs_]);
     }
 
     for (int bd = 0; bd < bd_block; bd++) {
@@ -843,7 +867,19 @@ void jit_brgemm_kernel_base_t::store_accumulators_apply_post_ops(
                     vcvtneps2bf16(ymm, zmm);
                     vmovdqu16(addr, r_ymm);
                     break;
-                case data_type::s8: vpmovsdb(addr, r_zmm); break;
+                case data_type::s8: {
+                    // hack, may be two flags
+                    if (brg.req_pre_compensation) {
+                        auto xmm = Xbyak::Xmm(zmm.getIdx());
+                        vpmovsdb(xmm, zmm);
+                        vpxord(xmm, xmm, xmm_compensation);
+                        auto r_addr = addr | k_mask;
+                        vmovdqu8(r_addr, xmm);
+                    } else {
+                        vpmovsdb(addr, r_zmm);
+                    }
+                    break;
+                }
                 case data_type::u8: vpmovusdb(addr, r_zmm); break;
                 default: assert(!"unknown dst_dt");
             }
@@ -865,7 +901,7 @@ void jit_brgemm_kernel_base_t::store_accumulators_without_post_ops(
     auto zmm_ubound = zmm_tmp_2();
     if (dt_requires_saturation) {
         init_saturate_f32(
-                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d);
+                zmm_lbound, zmm_ubound, reg_tmp_gpr, data_type::f32, brg.dt_d, true);
     }
 
     for (int bd = 0; bd < bd_block; bd++) {
@@ -1279,8 +1315,9 @@ void jit_brgemm_kernel_base_t::gemm_microkernel_avx512(int bd_block2,
             else if (brg.is_bf16 || brg.is_int8)
                 vpbroadcastd(z1, ptr[reg_aux_A + offset]);
         }
-
-        if (brg.req_s8s8_compensation) vpaddb(z1, z1, zmm_inp_shift());
+        // HACK !! Pre-compensate BRGEMM input at last quant
+        if (brg.req_s8s8_compensation && !brg.skip_input_s8_compensation)
+            vpaddb(z1, z1, zmm_inp_shift());
     };
 
     bool maybe_load_bytes = (rows_for_rd_tail > 0 || brg.brgattr.wary_tail_read)
@@ -1538,8 +1575,9 @@ void jit_brgemm_kernel_base_t::ldb_loop(int bd_block2, bool is_bdb_tail,
                 mov(reg_stride_lda, brg.typesize_A * brg.LDA);
                 mov(reg_stride_ldb, brg.rd_step * brg.typesize_B * brg.LDB);
             }
-
-            if (brg.req_s8s8_compensation) {
+            // HACK!! input already compensated or output need compensation?
+            if (brg.req_s8s8_compensation
+                    && !brg.skip_input_s8_compensation) {
                 mov(ptr[rsp + reg_bdb_loop_offs_], reg_bdb_loop);
                 mov(reg_s8_input_shift, 128);
                 vpbroadcastb(zmm_inp_shift(), reg_s8_input_shift.cvt8());
diff --git a/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp b/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp
index bd3b59026..6b8b617a0 100644
--- a/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp
+++ b/src/cpu/x64/injectors/jit_uni_eltwise_injector.cpp
@@ -43,7 +43,7 @@ bool is_alg_supported(alg_kind_t alg) {
             eltwise_relu_use_dst_for_bwd, eltwise_tanh_use_dst_for_bwd,
             eltwise_elu_use_dst_for_bwd, eltwise_sqrt_use_dst_for_bwd,
             eltwise_logistic_use_dst_for_bwd, eltwise_exp_use_dst_for_bwd,
-            eltwise_clip_v2_use_dst_for_bwd);
+            eltwise_clip_v2_use_dst_for_bwd, eltwise_gelu_erf_2dts);
 }
 
 bool is_supported(cpu_isa_t isa, alg_kind_t alg) {
@@ -70,7 +70,7 @@ void jit_uni_eltwise_injector_f32<isa>::injector_preamble(
             && utils::one_of(alg_, eltwise_tanh, eltwise_elu, eltwise_abs,
                     eltwise_soft_relu, eltwise_logsigmoid, eltwise_mish,
                     eltwise_logistic, eltwise_exp, eltwise_gelu_tanh,
-                    eltwise_swish, eltwise_gelu_erf,
+                    eltwise_swish, eltwise_gelu_erf, eltwise_gelu_erf_2dts,
                     eltwise_tanh_use_dst_for_bwd, eltwise_elu_use_dst_for_bwd,
                     eltwise_logistic_use_dst_for_bwd,
                     eltwise_exp_use_dst_for_bwd);
@@ -109,6 +109,11 @@ void jit_uni_eltwise_injector_f32<isa>::injector_preamble(
     assert(preserved_gprs_count == aux_gprs_count());
 
     if (save_state_) {
+        // HACK!!!
+        if (dynamic_scale_off != -1) {
+          h->push(p_param);
+          h->mov(p_param, h->rsp);
+        }
         h->push(p_table);
         for (size_t i = 0; i < preserved_gprs_count; ++i)
             h->push(Reg64(preserved_gpr_idxs[i]));
@@ -168,6 +173,11 @@ void jit_uni_eltwise_injector_f32<isa>::injector_postamble() {
     for (int i = aux_gprs_count() - 1; i >= 0; --i)
         h->pop(Reg64(preserved_gpr_idxs[i]));
     h->pop(p_table);
+
+    // HACK, restore stack
+    if (dynamic_scale_off != 0) {
+      h->pop(p_param);
+    }
 }
 
 template <cpu_isa_t isa>
@@ -1149,6 +1159,39 @@ void jit_uni_eltwise_injector_f32<isa>::gelu_erf_compute_vector_fwd(
     h->uni_vfmadd213ps(vmm_src, vmm_aux3, vmm_aux3);
 }
 
+template <cpu_isa_t isa>
+void jit_uni_eltwise_injector_f32<isa>::gelu_erf_2dts_compute_vector_fwd(
+        const Vmm &vmm_src) {
+    // Compute gelu using 2nd order polynormial solution
+    // Parameters from libxsmm and i-bert
+
+    // aux1 = x * rsqrt(2)
+    h->uni_vmulps(vmm_aux1, vmm_src, table_val(gelu_erf_one_over_sqrt_two));
+    // aux3 = x * rsqrt(2)
+    h->uni_vmovups(vmm_aux3, vmm_aux1);
+    // aux0 get sign
+    h->uni_vandps(vmm_aux0, vmm_aux1, table_val(sign_mask));
+
+    // aux1 = abs(x * rsqrt(2))
+    abs_compute_vector_fwd(vmm_aux1);
+    // aux2 = confine aux1 in [0, nb)
+    h->uni_vminps(vmm_aux2, vmm_aux1, table_val(gelu_erf_nb));
+
+    // compute 2nd order polynomial
+    // abs_erf = (a * aux2 + b) * aux2 + c
+    h->uni_vmovups(vmm_aux1, table_val(gelu_erf_a));
+    h->uni_vfmadd213ps(vmm_aux1, vmm_aux2, table_val(gelu_erf_b));
+    h->uni_vfmadd213ps(vmm_aux1, vmm_aux2, table_val(gelu_erf_c));
+
+    // sign erf
+    h->uni_vxorps(vmm_src, vmm_aux1, vmm_aux0);
+
+    // S = 0.5 * s = x / sqrt^2(2)
+    h->uni_vmulps(vmm_aux3, vmm_aux3, table_val(gelu_erf_one_over_sqrt_two));
+    // GELU = 0.5 * s * (1 + erf) = S + S * erf
+    h->uni_vfmadd213ps(vmm_src, vmm_aux3, vmm_aux3);
+}
+
 template <cpu_isa_t isa>
 void jit_uni_eltwise_injector_f32<isa>::relu_compute_vector_bwd(
         const Vmm &vmm_src) {
@@ -1566,6 +1609,7 @@ size_t jit_uni_eltwise_injector_f32<isa>::aux_vecs_count() {
             case eltwise_clip_v2: return 0;
             case eltwise_pow: return 2;
             case eltwise_gelu_erf: return 5;
+            case eltwise_gelu_erf_2dts: return 5; // Maybe 4???
             case eltwise_round: return 0;
             case eltwise_hardswish: return 1;
             default: assert(!"unsupported eltwise algorithm");
@@ -1659,6 +1703,9 @@ void jit_uni_eltwise_injector_f32<isa>::compute_body(
                 case eltwise_gelu_erf:
                     gelu_erf_compute_vector_fwd(Vmm(idx));
                     break;
+                case eltwise_gelu_erf_2dts:
+                    gelu_erf_2dts_compute_vector_fwd(Vmm(idx));
+                    break;
                 case eltwise_round: round_compute_vector_fwd(Vmm(idx)); break;
                 case eltwise_hardswish:
                     hardswish_compute_vector_fwd(Vmm(idx));
@@ -1713,7 +1760,12 @@ void jit_uni_eltwise_injector_f32<isa>::compute_body(
             }
         }
         if (scale_ != 1.f) {
+          if (dynamic_scale_off != -1) {
+            // HACK, only for AVX512F +
+            h->vmulps(Vmm(idx), Vmm(idx), stack_val(dynamic_scale_off));
+          } else {
             h->uni_vmulps(Vmm(idx), Vmm(idx), table_val(scale));
+          }
         }
     });
 }
@@ -2105,6 +2157,14 @@ void jit_uni_eltwise_injector_f32<isa>::register_table_entries() {
             {gelu_erf_pol, {0x3f87dc22, true}}, // p5 = 1.061405429f
     };
 
+    // gelu_erf(x) low-precision polynomial approximation
+    static const table_t gelu_erf_2dts {
+            {gelu_erf_a, {0xbe93dd98, true}}, // a = -0.2888f
+            {gelu_erf_b, {0x3f82c981, true}}, // b = 1.0217744f
+            {gelu_erf_c, {0x3dc519c3, true}}, // c = 0.0962405432f
+            {gelu_erf_nb, {0x3fe26e98, true}}, // nb = 1.769f
+    };
+
     // log(x) constants
     static const table_t log_consts {
             {log_minus_inf, {0xff800000, true}},
@@ -2238,6 +2298,7 @@ void jit_uni_eltwise_injector_f32<isa>::register_table_entries() {
                 case eltwise_logistic:
                 case eltwise_swish: exp_ = true; break;
                 case eltwise_gelu_erf: gelu_erf_ = true; break;
+                case eltwise_gelu_erf_2dts: gelu_erf_ = true; break;
                 case eltwise_gelu_tanh: gelu_tanh_ = true; break;
                 case eltwise_log: log_ = true; break;
                 case eltwise_soft_relu: soft_relu_ = true; break;
@@ -2297,8 +2358,13 @@ void jit_uni_eltwise_injector_f32<isa>::register_table_entries() {
     if (need.soft_relu()) push_entries_of(soft_relu_consts);
     if (need.soft_relu()) push_entries_of(soft_relu_polynomial);
     if (need.gelu_tanh()) push_entries_of(gelu_tanh_consts);
-    if (need.gelu_erf()) push_entries_of(gelu_erf_consts);
-    if (need.gelu_erf()) push_entries_of(gelu_erf_polynomial);
+
+    if (need.gelu_erf()) {
+      push_entries_of(gelu_erf_consts);
+      push_entries_of(gelu_erf_polynomial);
+      push_entries_of(gelu_erf_2dts);
+    }
+
     if (need.log()) push_entries_of(log_consts);
     if (need.log()) push_entries_of(log_polynomial);
     if (need.log()) push_entries_of(log_predefined_values);
diff --git a/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp b/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp
index f373d9ccb..439dcc2bb 100644
--- a/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp
+++ b/src/cpu/x64/injectors/jit_uni_eltwise_injector.hpp
@@ -38,18 +38,33 @@ struct static_params_t {
     static_params_t(bool save_state = true,
             Xbyak::Reg64 p_table = Xbyak::util::rax,
             Xbyak::Opmask k_mask = Xbyak::Opmask(1), bool is_fwd = true,
-            bool use_dst = false)
+            bool use_dst = false,
+            Xbyak::Reg64 p_param = Xbyak::util::rdi,
+            ssize_t dynamic_scale_off = -1)
         : save_state(save_state)
         , p_table(p_table)
+        , p_param(p_param)
         , k_mask(k_mask)
         , is_fwd(is_fwd)
-        , use_dst(use_dst) {}
+        , use_dst(use_dst)
+        , dynamic_scale_off(dynamic_scale_off) {}
+
+    static_params_t(size_t dynamic_scale_off)
+        : save_state(true)
+        , p_table(Xbyak::util::rax)
+        , p_param(Xbyak::util::rdi)
+        , k_mask(Xbyak::Opmask(1))
+        , is_fwd(true)
+        , use_dst(false)
+        , dynamic_scale_off(dynamic_scale_off) {}
 
     bool save_state;
     Xbyak::Reg64 p_table;
+    Xbyak::Reg64 p_param;
     Xbyak::Opmask k_mask;
     bool is_fwd;
     bool use_dst;
+    ssize_t dynamic_scale_off;
 };
 
 /*
@@ -86,17 +101,23 @@ struct jit_uni_eltwise_injector_f32 {
     // use_dst - defines whether source or destination point is passed to alg
     //   code. Depends on algorithm. See `_use_dst_for_bwd` algs definition.
     jit_uni_eltwise_injector_f32(jit_generator *host, alg_kind_t alg,
-            float alpha, float beta, float scale, bool save_state = true,
+            float alpha, float beta, float scale,
+            bool save_state = true,
             Xbyak::Reg64 p_table = Xbyak::util::rax,
             Xbyak::Opmask k_mask = Xbyak::Opmask(1), bool is_fwd = true,
-            bool use_dst = false)
+            bool use_dst = false,
+            // HACK
+            Xbyak::Reg64 p_param = Xbyak::util::rdi,
+            ssize_t dynamic_scale_off = -1)
         : alg_(alg)
         , alpha_(alpha)
         , beta_(beta)
         , scale_(scale)
+        , dynamic_scale_off(dynamic_scale_off)
         , h(host)
         , save_state_(save_state)
         , p_table(p_table)
+        , p_param(p_param)
         , k_mask(k_mask)
         , is_fwd_(is_fwd)
         , use_dst_(use_dst) {
@@ -109,10 +130,12 @@ struct jit_uni_eltwise_injector_f32 {
             const post_ops_t::entry_t::eltwise_t &eltwise,
             bool save_state = true, Xbyak::Reg64 p_table = Xbyak::util::rax,
             Xbyak::Opmask k_mask = Xbyak::Opmask(1), bool is_fwd = true,
-            bool use_dst = false)
+            bool use_dst = false,
+            Xbyak::Reg64 p_param = Xbyak::util::rdi,
+            ssize_t dynamic_scale_off = -1)
         : jit_uni_eltwise_injector_f32(host, eltwise.alg, eltwise.alpha,
                 eltwise.beta, eltwise.scale, save_state, p_table, k_mask,
-                is_fwd, use_dst) {}
+                is_fwd, use_dst, p_param, dynamic_scale_off) {}
 
     void compute_vector_range(size_t start_idx, size_t end_idx);
     void compute_vector_range(const injector_utils::vmm_index_set_t &vmm_idxs);
@@ -125,11 +148,13 @@ private:
     const float alpha_;
     const float beta_;
     const float scale_;
+    const ssize_t dynamic_scale_off;
 
     jit_generator *const h;
 
     const bool save_state_;
     const Xbyak::Reg64 p_table;
+    const Xbyak::Reg64 p_param;
     const Xbyak::Opmask k_mask;
     const bool is_fwd_;
     const bool use_dst_;
@@ -208,6 +233,7 @@ private:
     void clip_compute_vector_fwd(const Vmm &vmm_src);
     void pow_compute_vector_fwd(const Vmm &vmm_src);
     void gelu_erf_compute_vector_fwd(const Vmm &vmm_src);
+    void gelu_erf_2dts_compute_vector_fwd(const Vmm &vmm_src);
     void round_compute_vector_fwd(const Vmm &vmm_src);
     void hardswish_compute_vector_fwd(const Vmm &vmm_src);
 
@@ -272,6 +298,10 @@ private:
         gelu_erf_one_over_sqrt_two, // 1.f / sqrtf(2.f)
         gelu_erf_one_over_sqrt_pi, // 1.f / sqrtf(pi) = 0.564190f
         gelu_erf_pol, // see correspondent table for float values
+        gelu_erf_a, // -0.2888f
+        gelu_erf_b, // 1.0217744f
+        gelu_erf_c, // 0.0962405432f
+        gelu_erf_nb, // 1.769f
         log_minus_inf, // -inf
         log_qnan, // qnan
         log_mantissa_mask, // gets mantissa bits
@@ -297,6 +327,10 @@ private:
         auto off = table_off(key, key_off_val_shift);
         return h->ptr[p_table + off];
     }
+    // HACK: Get scale in stack frame, signaled when p_param != p_table
+    Xbyak::Address stack_val(size_t off) {
+        return h->zword_b[p_param + off + 8];
+    }
 
     // we accept only 32bit hexadecimal table values to avoid any rounding
     using table_entry_val_t = uint32_t;
diff --git a/src/cpu/x64/injectors/jit_uni_postops_injector.cpp b/src/cpu/x64/injectors/jit_uni_postops_injector.cpp
index fff4eef4e..d8c598aaa 100644
--- a/src/cpu/x64/injectors/jit_uni_postops_injector.cpp
+++ b/src/cpu/x64/injectors/jit_uni_postops_injector.cpp
@@ -65,7 +65,7 @@ jit_uni_postops_injector_t<isa, Vmm>::jit_uni_postops_injector_t(
             alg_to_eltwise_injector_.emplace(post_op.eltwise.alg,
                     jit_uni_eltwise_injector_f32<isa>(host_, post_op.eltwise,
                             esp.save_state, esp.p_table, esp.k_mask, esp.is_fwd,
-                            esp.use_dst));
+                            esp.use_dst, esp.p_param, esp.dynamic_scale_off));
         } else if (post_op.is_binary()) {
             is_binary = true;
         }
diff --git a/src/cpu/x64/jit_brgemm_inner_product.cpp b/src/cpu/x64/jit_brgemm_inner_product.cpp
index 38381ecbb..f778a696e 100644
--- a/src/cpu/x64/jit_brgemm_inner_product.cpp
+++ b/src/cpu/x64/jit_brgemm_inner_product.cpp
@@ -19,6 +19,8 @@
 #include "common/type_helpers.hpp"
 #include "common/utils.hpp"
 
+#include "cpu/cpu_primitive.hpp"
+
 #include "cpu/x64/amx_tile_configure.hpp"
 #include "cpu/x64/cpu_barrier.hpp"
 #include "cpu/x64/injectors/jit_uni_binary_injector.hpp"
@@ -55,7 +57,7 @@ void copy_data_chunk(ker_type &ker, char *tr_data, const char *data,
 } // namespace
 
 template <cpu_isa_t isa>
-void brgemm_inner_product_fwd_t<isa>::execute_forward(
+status_t brgemm_inner_product_fwd_t<isa>::execute_forward(
         const exec_ctx_t &ctx) const {
     auto src = CTX_IN_MEM(const char *, DNNL_ARG_SRC);
     auto weights = CTX_IN_MEM(const char *, DNNL_ARG_WEIGHTS);
@@ -70,7 +72,9 @@ void brgemm_inner_product_fwd_t<isa>::execute_forward(
     const memory_desc_wrapper dst_d(pd()->dst_md());
     const memory_desc_wrapper weights_d(pd()->weights_md(0));
 
-    const float *oscales = pd()->attr()->output_scales_.scales_;
+    DEFINE_SCALES_BUFFER(oscales);
+    auto* pf_scale = CTX_IN_MEM(const float *, DNNL_ARG_SCALE);
+    auto final_scale = (pf_scale == nullptr) ? 1.f : *pf_scale;
 
     const auto &jbgp = pd()->jbgp_;
     const bool is_f32 = everyone_is(f32, jbgp.src_dt, jbgp.wei_dt, jbgp.dst_dt);
@@ -206,6 +210,7 @@ void brgemm_inner_product_fwd_t<isa>::execute_forward(
                 const brgemm_post_ops_data_t post_ops_data {
                         static_cast<const void *>(ptr_bias),
                         &oscales[jbgp.is_oc_scale * oc],
+                        final_scale,
                         post_ops_binary_rhs_arg_vec.data(),
                         static_cast<size_t>(oc), 0, dst};
 
@@ -249,6 +254,7 @@ void brgemm_inner_product_fwd_t<isa>::execute_forward(
                 const brgemm_post_ops_data_t post_ops_data {
                         static_cast<const void *>(ptr_bias),
                         &oscales[jbgp.is_oc_scale * oc],
+                        final_scale,
                         post_ops_binary_rhs_arg_vec.data(),
                         static_cast<size_t>(oc)};
 
@@ -439,6 +445,7 @@ void brgemm_inner_product_fwd_t<isa>::execute_forward(
                             const brgemm_post_ops_data_t post_ops_data {
                                     static_cast<const void *>(ptr_bias),
                                     &oscales[jbgp.is_oc_scale * oc],
+                                    final_scale,
                                     post_ops_binary_rhs_arg_vec.data(),
                                     static_cast<size_t>(oc), 0, dst, 0, nullptr,
                                     nullptr, nullptr, true /* skip_accm */};
@@ -453,6 +460,8 @@ void brgemm_inner_product_fwd_t<isa>::execute_forward(
             }
         });
     }
+
+    return status::success;
 }
 
 template struct brgemm_inner_product_fwd_t<avx512_core>;
diff --git a/src/cpu/x64/jit_brgemm_inner_product.hpp b/src/cpu/x64/jit_brgemm_inner_product.hpp
index ef941eff4..d0c98ef4a 100644
--- a/src/cpu/x64/jit_brgemm_inner_product.hpp
+++ b/src/cpu/x64/jit_brgemm_inner_product.hpp
@@ -48,6 +48,17 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
         DECLARE_COMMON_PD_T(JIT_IMPL_NAME_HELPER("brgemm:", isa, ""),
                 brgemm_inner_product_fwd_t);
 
+        arg_usage_t arg_usage(int arg) const override {
+            if (utils::one_of(arg, DNNL_ARG_SRC, DNNL_ARG_WEIGHTS, DNNL_ARG_SCALE))
+                return arg_usage_t::input;
+
+            if (arg == DNNL_ARG_BIAS && with_bias()) return arg_usage_t::input;
+
+            if (arg == DNNL_ARG_DST) return arg_usage_t::output;
+
+            return primitive_desc_t::arg_usage(arg);
+        }
+
         status_t init(engine_t *engine) {
             using namespace utils;
             using namespace data_type;
@@ -58,7 +69,8 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
 
             using skip_mask_t = primitive_attr_t::skip_mask_t;
             auto skip_mask = skip_mask_t::post_ops;
-            if (one_of(src_dt, u8, s8)) skip_mask |= skip_mask_t::oscale;
+            if (one_of(src_dt, u8, s8)) skip_mask |= skip_mask_t::oscale
+                | skip_mask_t::oscale_runtime;
 
             bool ok = is_fwd() && mayiuse(isa)
                     && expect_data_types(src_dt, wei_dt, data_type::undef,
@@ -105,6 +117,8 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
                         jbgp_.wei_dt, false, false, brgemm_row_major, alpha,
                         vbeta, jbgp_.LDA, jbgp_.LDB, jbgp_.LDC, vM, vN, vK));
 
+                adjust_compensation(&brg);
+
                 auto LDD = jbgp_.oc_without_padding;
                 CHECK(brgemm_desc_set_postops(
                         &brg, attr(), &dst_md_, LDD, jbgp_.bia_dt));
@@ -148,6 +162,24 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
 
         brgemm_t brg_descs_[brgemm_inner_product_utils::max_num_brg_kernels_ip];
         jit_brgemm_primitive_conf_t jbgp_;
+    private:
+        // HACK use forward training signal pre-compensation
+        bool skip_compensation() {
+            return desc_.prop_kind == prop_kind::forward_training;
+        }
+
+        // HACK, if forward training with eltwise enabled
+        bool req_pre_compensation() {
+            return desc_.prop_kind == prop_kind::forward_training
+                && jbgp_.with_eltwise;
+        }
+
+        void adjust_compensation(brgemm_t *brg) {
+            brg->skip_input_s8_compensation = brg->req_s8s8_compensation
+                && skip_compensation();
+
+            brg->req_pre_compensation = req_pre_compensation();
+        }
     };
 
     brgemm_inner_product_fwd_t(const pd_t *apd) : primitive_t(apd) {}
@@ -179,12 +211,11 @@ struct brgemm_inner_product_fwd_t : public primitive_t {
     }
 
     status_t execute(const exec_ctx_t &ctx) const override {
-        execute_forward(ctx);
-        return status::success;
+        return execute_forward(ctx);
     }
 
 private:
-    void execute_forward(const exec_ctx_t &ctx) const;
+    status_t execute_forward(const exec_ctx_t &ctx) const;
     const pd_t *pd() const { return (const pd_t *)primitive_t::pd().get(); }
 
     std::unique_ptr<brgemm_kernel_t>
diff --git a/src/cpu/x64/jit_brgemm_post_ops.hpp b/src/cpu/x64/jit_brgemm_post_ops.hpp
index 0f10844a8..2b0d3164b 100644
--- a/src/cpu/x64/jit_brgemm_post_ops.hpp
+++ b/src/cpu/x64/jit_brgemm_post_ops.hpp
@@ -517,7 +517,7 @@ private:
         auto zmm_ubound = Xbyak::Zmm(30);
         if (dt_requires_saturation) {
             init_saturate_f32(zmm_lbound, zmm_ubound, reg_tmp_gpr,
-                    data_type::f32, brg.dt_d);
+                    data_type::f32, brg.dt_d, true);
         }
 
         for_(int m = 0; m < m_block; m++)
diff --git a/src/cpu/x64/jit_gemm_inner_product_utils.cpp b/src/cpu/x64/jit_gemm_inner_product_utils.cpp
index 919706623..3dc78024e 100644
--- a/src/cpu/x64/jit_gemm_inner_product_utils.cpp
+++ b/src/cpu/x64/jit_gemm_inner_product_utils.cpp
@@ -43,7 +43,7 @@ struct jit_pp_kernel_t : public pp_kernel_t<acc_type, dst_type>,
 
     jit_pp_kernel_t(size_t OC, size_t MB, dim_t dst_mb_stride,
             const primitive_attr_t *attr, data_type_t bias_dt,
-            const memory_desc_t *dst_md, bool skip_sum);
+            const memory_desc_t *dst_md, bool skip_sum, bool pcomp = false);
 
     using acc_data_t = typename prec_traits<acc_type>::type;
     using dst_data_t = typename prec_traits<dst_type>::type;
@@ -162,6 +162,7 @@ private:
     // Will be assigned in constructor
     Vmm vreg_zero, vreg_saturation_ubound, vreg_scale, vreg_sum_scale,
             vreg_sum_zp, vreg_dst_zero_points;
+    Vmm Vreg_compensation;
 
     const Xbyak::Reg64 &eltwise_reserved_gpr_ = r11;
     const Xbyak::Opmask &eltwise_reserved_opmask_ = k2;
@@ -266,15 +267,19 @@ private:
 template <cpu_isa_t isa, data_type_t acc_type, data_type_t dst_type>
 jit_pp_kernel_t<isa, acc_type, dst_type>::jit_pp_kernel_t(size_t OC, size_t MB,
         dim_t dst_mb_stride, const primitive_attr_t *attr, data_type_t bias_dt,
-        const memory_desc_t *dst_md, bool skip_sum)
+        const memory_desc_t *dst_md, bool skip_sum, bool pcomp)
     : pp_kernel_t<acc_type, dst_type>(
-            OC, MB, dst_mb_stride, attr, bias_dt, dst_md->ndims, skip_sum) {
+            OC, MB, dst_mb_stride, attr, bias_dt, dst_md->ndims, skip_sum, pcomp) {
     assert(IMPLICATION(dst_type == data_type::bf16, mayiuse(avx512_core)));
     assert(isa != avx512_common);
 
     if (this->do_scale_) vreg_scale = Vmm(idx_compute_vreg_start_++);
 
-    if (dst_type == data_type::u8) vreg_zero = Vmm(idx_compute_vreg_start_++);
+    if (dst_type == data_type::u8 || dst_type==data_type::s8) {
+        vreg_zero = Vmm(idx_compute_vreg_start_++);
+        if (this->do_precompensation)
+          Vreg_compensation = Vmm(idx_compute_vreg_start_ ++);
+    }
     if (utils::one_of(dst_type, data_type::u8, data_type::s8, data_type::s32))
         vreg_saturation_ubound = Vmm(idx_compute_vreg_start_++);
 
@@ -582,7 +587,18 @@ void jit_pp_kernel_t<isa, acc_type, dst_type>::cvt_and_store(
     auto v_src = tail ? v | kreg_rem_mask : v;
     const Xbyak::Address dst = get_address(arg_num, off);
     switch (dt) {
-        case s8: vpmovsdb(dst, v_src); break;
+        case s8: {
+          auto v_xmm = Xmm(v.getIdx());
+          auto dst_k = tail ? dst | kreg_rem_mask : dst;
+          if (this->do_precompensation) {
+            vpmovsdb(v_xmm, v);
+            vpxord(v_xmm, v_xmm, Xmm(Vreg_compensation.getIdx()));
+            vmovdqu8(dst_k, v_xmm);
+          } else {
+            vpmovsdb(dst, v_src);
+          }
+        }
+        break;
         case u8: vpmovusdb(dst, v_src); break;
         case f32:
         case s32: uni_vmovups(dst, v_src); break;
@@ -1128,6 +1144,11 @@ void jit_pp_kernel_t<isa, acc_type, dst_type>::generate() {
         mov(reg_oc, ptr[reg_param + PARAM_OFF(dst_zero_points)]);
         uni_vbroadcastss(vreg_dst_zero_points, ptr[reg_oc]);
     }
+    // HACK, do precompensation
+    if (this->do_precompensation) {
+        mov(reg_oc.cvt32(), 0x80808080);
+        vpbroadcastd(Vreg_compensation, reg_oc.cvt32());
+    }
     if (this->runtime_oc())
         mov(reg_oc, ptr[reg_param + PARAM_OFF(oc)]);
     else
@@ -1186,7 +1207,7 @@ void jit_pp_kernel_t<isa, acc_type, dst_type>::generate() {
     }
 
     init_saturate_f32(vreg_zero, vreg_saturation_ubound, reg_tmp_comp,
-            data_type::f32, dst_type);
+            data_type::f32, dst_type, true);
 
     // at least 2 blocks of mb within vlen
     bool dim_restrict = !this->runtime_oc() && !this->runtime_mb()
@@ -1253,13 +1274,13 @@ void jit_pp_kernel_t<isa, acc_type, dst_type>::operator()(dst_data_t *dst,
 template <data_type_t acc_type, data_type_t dst_type>
 pp_kernel_t<acc_type, dst_type> *jit_pp_kernel_create(size_t OC, size_t MB,
         dim_t dst_mb_stride, const primitive_attr_t *attr, data_type_t bias_dt,
-        const memory_desc_t *dst_md, bool skip_sum) {
+        const memory_desc_t *dst_md, bool skip_sum, bool pcomp) {
     if (mayiuse(avx512_core_bf16)) {
         return new jit_pp_kernel_t<avx512_core_bf16, acc_type, dst_type>(
                 OC, MB, dst_mb_stride, attr, bias_dt, dst_md, skip_sum);
     } else if (mayiuse(avx512_core)) {
         return new jit_pp_kernel_t<avx512_core, acc_type, dst_type>(
-                OC, MB, dst_mb_stride, attr, bias_dt, dst_md, skip_sum);
+                OC, MB, dst_mb_stride, attr, bias_dt, dst_md, skip_sum, pcomp);
     } else if (mayiuse(avx2)) {
         return new jit_pp_kernel_t<avx2, acc_type, dst_type>(
                 OC, MB, dst_mb_stride, attr, bias_dt, dst_md, skip_sum);
@@ -1275,7 +1296,7 @@ pp_kernel_t<acc_type, dst_type> *jit_pp_kernel_create(size_t OC, size_t MB,
     template pp_kernel_t<acc_type, dst_type> * \
     jit_pp_kernel_create<acc_type, dst_type>(size_t OC, size_t MB, \
             dim_t dst_mb_stride, const primitive_attr_t *attr, \
-            data_type_t bias_dt, const memory_desc_t *dst_md, bool skip_sum);
+            data_type_t bias_dt, const memory_desc_t *dst_md, bool skip_sum, bool);
 
 using namespace data_type;
 INST(f32, f32);
diff --git a/src/cpu/x64/jit_gemm_inner_product_utils.hpp b/src/cpu/x64/jit_gemm_inner_product_utils.hpp
index b9f4060f8..f151e7a0a 100644
--- a/src/cpu/x64/jit_gemm_inner_product_utils.hpp
+++ b/src/cpu/x64/jit_gemm_inner_product_utils.hpp
@@ -28,7 +28,8 @@ namespace inner_product_utils {
 template <data_type_t acc_type, data_type_t dst_type>
 cpu::inner_product_utils::pp_kernel_t<acc_type, dst_type> *jit_pp_kernel_create(
         size_t OC, size_t MB, dim_t dst_mb_stride, const primitive_attr_t *attr,
-        data_type_t bias_dt, const memory_desc_t *dst_md, bool skip_sum);
+        data_type_t bias_dt, const memory_desc_t *dst_md, bool skip_sum,
+        bool pcomp=false);
 
 constexpr cpu_isa_t jit_pp_kernel_supported_isa() {
     return sse41;
diff --git a/src/cpu/x64/jit_generator.hpp b/src/cpu/x64/jit_generator.hpp
index 8b2925f91..94744bac1 100644
--- a/src/cpu/x64/jit_generator.hpp
+++ b/src/cpu/x64/jit_generator.hpp
@@ -1493,7 +1493,7 @@ public:
      */
     template <typename Vmm>
     void init_saturate_f32(Vmm vmm_lbound, Vmm vmm_ubound, Xbyak::Reg64 reg_tmp,
-            data_type_t idt, data_type_t odt) {
+            data_type_t idt, data_type_t odt, bool elevated_min = true) {
         using namespace data_type;
         if (!((idt == f32) && utils::one_of(odt, u8, s8, s32))) return;
 
@@ -1512,6 +1512,19 @@ public:
             uni_vbroadcastss(vmm_ubound, tmp);
         else
             uni_vshufps(vmm_ubound, tmp, tmp, 0);
+
+        // Specific for elevated s8 min
+        if (odt == s8 && elevated_min) {
+          Xbyak::Xmm tmp(vmm_lbound.getIdx());
+          float saturation_lbound =
+            nstl::numeric_limits<prec_traits<s8>::type>::min() + 1;
+          mov(reg_tmp, float2int(saturation_lbound));
+          uni_vmovq(tmp, reg_tmp);
+          if (vmm_lbound.isYMM() || vmm_lbound.isZMM())
+              uni_vbroadcastss(vmm_lbound, tmp);
+          else
+              uni_vshufps(vmm_lbound, tmp, tmp, 0);
+        }
     }
 
     template <typename Vmm>
@@ -1525,9 +1538,9 @@ public:
         if (!utils::one_of(odt, u8, s8, s32)) return;
 
         // no need to apply lower saturation bound when odt is
-        // signed, as cvtps2dq will return MIN_INT if the value
+        // 32-bit signed, as cvtps2dq will return MIN_INT if the value
         // does not fit
-        if (odt == u8) {
+        if (odt == u8 || odt == s8) {
             if (is_valid_isa(avx))
                 vmaxps(vmm, vmm, vmm_lbound);
             else
diff --git a/tests/benchdnn/ip/ip.cpp b/tests/benchdnn/ip/ip.cpp
index 1c314024b..501a49cac 100644
--- a/tests/benchdnn/ip/ip.cpp
+++ b/tests/benchdnn/ip/ip.cpp
@@ -314,6 +314,9 @@ int doit(const prb_t *prb, res_t *res) {
     dnn_mem_t bia_dt(bia_md, test_engine);
     dnn_mem_t dst_dt(dst_md, test_engine);
     dnn_mem_t scratchpad_dt(scratchpad_md, test_engine);
+    dnn_mem_t scales;
+    maybe_prepare_runtime_scales(scales, prb->attr.oscale, prb->oc, prb->scales);
+
     std::vector<dnn_mem_t> binary_po_fp, binary_po_dt;
     std::vector<int> binary_po_args;
     SAFE(binary::setup_binary_po(
@@ -338,6 +341,7 @@ int doit(const prb_t *prb, res_t *res) {
         args.set(DNNL_ARG_BIAS, bia_dt);
         args.set(DNNL_ARG_DST, dst_dt);
         args.set(DNNL_ARG_SCRATCHPAD, scratchpad_dt);
+        args.set(DNNL_ARG_ATTR_OUTPUT_SCALES, scales);
         args.set(binary_po_args, binary_po_dt);
 
         SAFE(execute_and_wait(prim, args), WARN);
